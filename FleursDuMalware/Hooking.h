#pragma once

#include "Global.h"
#include <Windows.h>
#include <tlhelp32.h>
#include <winnt.h>
#include <list>
#include <string>


// From: https://github.com/Mr-Un1k0d3r/EDRs/blob/main/patch_syscall_dynamically64.c
bool checkJmpHooked(char* name, DWORD* address, BOOL bNt) {
    BYTE* opcode = (BYTE*)address;

    // TODO: EDR/AV might bust this string array; for better stealth, take this out of your final program
    // if you know what to unhook.
    const char* falsePositives[] = {
        "NtGetTickCount",
        "NtQuerySystemTime",
        "NtdllDefWindowProc_A",
        "NtdllDefWindowProc_W",
        "NtdllDialogWndProc_A",
        "NtdllDialogWndProc_W",
        "ZwQuerySystemTime"
    };

    // Some EDRs hook more than Nt* API. Ex: LdrLoadDll 
    if (bNt) {
        if (!(name[0] == 'N' && name[1] == 't')) {
            return false;
        }
    }
    

    // not all EDRs hook the first byte you will miss some hook
    if (*opcode == 0xe9) { 
        // Handle a few false positives...
        // See: https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions
        for (int i = 0; i < (sizeof(falsePositives) / sizeof(const char*)); i++) {
            if (strcmp(name, falsePositives[i]) == 0)
                return false;
        }
        return true;
    }

    return false;
}

struct FunctionWithName {
    std::string name;
    void* startAddr = 0;
};

std::list<FunctionWithName> getListOfExport(HMODULE libraryStartAddr) {

    std::list<FunctionWithName> lstFunctions = std::list<FunctionWithName>();

    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)libraryStartAddr;
    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)libraryStartAddr + MZ->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* exportDirectory = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)libraryStartAddr + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* addrOfNames = (DWORD*)((BYTE*)libraryStartAddr + exportDirectory->AddressOfNames);

    for (DWORD i = 0; i < exportDirectory->NumberOfNames; i++) {

        // Creates a string fron the function name.
        FunctionWithName functionWithName = FunctionWithName();
        functionWithName.name = std::string((CHAR*)libraryStartAddr + addrOfNames[i]);;
        functionWithName.startAddr = (DWORD*)GetProcAddress(libraryStartAddr, (char*)libraryStartAddr + addrOfNames[i]);

        lstFunctions.push_back(functionWithName);
        PRINT_DEBUG("%p: %s\n", functionWithName.startAddr, functionWithName.name.c_str());
    }

    return lstFunctions;
}

std::list<FunctionWithName> getListOfHookedFunctions(std::list<FunctionWithName> funcList, bool checkOnlyNt = true) {

    std::list<FunctionWithName> lstHookedFunctions = std::list<FunctionWithName>();

    for (std::list<FunctionWithName>::iterator it = funcList.begin(); it != funcList.end(); ++it) {

        bool isHooked = checkJmpHooked((char*)it->name.c_str(), (DWORD*) it->startAddr, checkOnlyNt);

        //If the function is hooked, we push it to our array.
        if (isHooked) {
            lstHookedFunctions.push_back(*it);
            PRINT_DEBUG("%p: %s - is HOOKED.\n", it->startAddr, it->name.c_str());
        }
    }

    return lstHookedFunctions;
}

std::list<FunctionWithName> getListOfHookedFunctions(HMODULE libraryStartAddr, bool checkOnlyNt = true) {

    std::list<FunctionWithName> fnsWithName = getListOfExport(libraryStartAddr);
    std::list<FunctionWithName> lstHookedFunctions = getListOfHookedFunctions(fnsWithName);

    return lstHookedFunctions;
}