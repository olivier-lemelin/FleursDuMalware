#pragma once

#include "Global.h"
#include <Windows.h>
#include <tlhelp32.h>
#include <winnt.h>
#include <list>
#include <string>

bool checkJmpHooked(char* name, DWORD* address, BOOL bNt) {
    BYTE* opcode = (BYTE*)address;

    // Some EDRs hook more than Nt* API. Ex: LdrLoadDll 
    if (bNt) {
        if (!(name[0] == 'N' && name[1] == 't')) {
            return false;
        }
    }

    // not all EDRs hook the first byte you will miss some hook
    return (*opcode == 0xe9);
}

struct FunctionWithName {
    std::string name;
    void* startAddr;
};

std::list<FunctionWithName> GetListOfExport(HMODULE libraryStartAddr, bool checkOnlyNtFunctions) {

    std::list<FunctionWithName> lstFunctions = std::list<FunctionWithName>();

    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)libraryStartAddr;
    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)libraryStartAddr + MZ->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* exportDirectory = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)libraryStartAddr + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* addrOfNames = (DWORD*)((BYTE*)libraryStartAddr + exportDirectory->AddressOfNames);

    for (DWORD i = 0; i < exportDirectory->NumberOfNames; i++) {

        // Creates a string fron the function name.
        FunctionWithName functionWithName = FunctionWithName();
        functionWithName.name = std::string((CHAR*)libraryStartAddr + addrOfNames[i]);;
        functionWithName.startAddr = (DWORD*)GetProcAddress(libraryStartAddr, (char*)libraryStartAddr + addrOfNames[i]);

        // Checks if the function is hooked.
        //bool isHooked = checkJmpHooked((char*)functionName.c_str(), (DWORD*)GetProcAddress(libraryStartAddr, (char*)libraryStartAddr + addrOfNames[i]), checkOnlyNtFunctions);
        lstFunctions.push_back(functionWithName);
        PRINT_DEBUG("%p: %s\n", functionWithName.startAddr, functionWithName.name.c_str());
    }

    return lstFunctions;
}

/*std::list<std::string> getHookedFunctions(std::list<functionWithName> funcList) {
}*/